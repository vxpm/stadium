#![deny(unsafe_op_in_unsafe_fn)]
#![deny(clippy::undocumented_unsafe_blocks)]
#![deny(clippy::missing_safety_doc)]
#![warn(clippy::trivially_copy_pass_by_ref)]
#![warn(
    clippy::bool_to_int_with_if,
    clippy::borrow_as_ptr,
    clippy::case_sensitive_file_extension_comparisons,
    clippy::cast_lossless,
    clippy::cast_ptr_alignment,
    clippy::checked_conversions,
    clippy::cloned_instead_of_copied,
    clippy::copy_iterator,
    clippy::default_union_representation,
    clippy::deref_by_slicing,
    clippy::doc_link_with_quotes,
    clippy::empty_drop,
    clippy::empty_structs_with_brackets,
    clippy::enum_glob_use,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::filter_map_next,
    clippy::flat_map_option,
    clippy::float_cmp,
    clippy::float_cmp_const,
    clippy::fn_params_excessive_bools,
    clippy::fn_to_numeric_cast_any,
    clippy::format_push_string,
    clippy::if_then_some_else_none,
    clippy::ignored_unit_patterns,
    clippy::implicit_clone,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::large_digit_groups,
    clippy::large_stack_arrays,
    clippy::large_types_passed_by_value,
    clippy::linkedlist,
    clippy::lossy_float_literal,
    clippy::macro_use_imports,
    clippy::manual_assert,
    clippy::manual_instant_elapsed,
    clippy::manual_let_else,
    clippy::manual_ok_or,
    clippy::manual_ok_or,
    clippy::manual_string_new,
    clippy::map_unwrap_or,
    clippy::match_bool,
    clippy::mem_forget,
    clippy::mismatching_type_param_order,
    clippy::multiple_inherent_impl,
    clippy::mut_mut,
    clippy::mutex_atomic,
    clippy::needless_bitwise_bool,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::needless_for_each,
    clippy::needless_raw_string_hashes,
    clippy::needless_raw_strings,
    clippy::negative_feature_names,
    clippy::no_mangle_with_rust_abi,
    clippy::non_send_fields_in_send_ty,
    clippy::option_option,
    clippy::partial_pub_fields,
    clippy::ptr_cast_constness,
    clippy::range_minus_one,
    clippy::rc_mutex,
    clippy::redundant_else,
    clippy::redundant_feature_names,
    clippy::ref_option_ref,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::single_char_lifetime_names,
    clippy::single_match_else,
    clippy::string_add,
    clippy::string_add_assign,
    clippy::string_lit_chars_any,
    clippy::string_to_string,
    clippy::struct_field_names,
    clippy::transmute_ptr_to_ptr,
    clippy::trivially_copy_pass_by_ref,
    clippy::unnested_or_patterns,
    clippy::unreadable_literal,
    clippy::unsafe_derive_deserialize,
    clippy::unused_self,
    clippy::verbose_file_reads,
    clippy::zero_sized_map_values,
    nonstandard_style
)]

pub mod auxiliary;
use std::marker::PhantomData;

mod sealed {
    pub trait Sealed {}

    impl Sealed for u8 {}
    impl Sealed for u16 {}
    impl Sealed for u32 {}
    impl Sealed for u64 {}
    impl Sealed for u128 {}
    impl Sealed for super::NoGen {}
}

/// A trait for types which can be used as the index in a stadium.
///
/// # Safety
/// - `next` and `previous` must be inverses
/// - `from_usize` and `to_usize` must only panic on out-of-range values
pub unsafe trait Index: Copy + PartialEq + Eq + PartialOrd + Ord + sealed::Sealed {
    fn next(self) -> Option<Self>;
    fn previous(self) -> Option<Self>;

    fn from_usize(value: usize) -> Self;
    fn to_usize(self) -> usize;
}

macro_rules! impl_index {
    ($($ty:ty),*) => {
        $(
            // SAFETY: invariants upheld
            unsafe impl Index for $ty {
                #[inline(always)]
                fn next(self) -> Option<Self> {
                    self.checked_add(1)
                }

                #[inline(always)]
                fn previous(self) -> Option<Self> {
                    self.checked_sub(1)
                }

                #[inline(always)]
                fn from_usize(value: usize) -> Self {
                    Self::try_from(value).unwrap()
                }

                #[inline(always)]
                fn to_usize(self) -> usize {
                    usize::try_from(self).unwrap()
                }
            }
        )*
    };
}

impl_index! {
    u8,
    u16,
    u32,
    u64,
    u128
}

/// Trait for types that can be used as the generation of the seats in [`RawStadium`].
///
/// # Predictability
/// The behaviour of a stadium depends on whether or not the generation type is well-behaved. For
/// well-behaved types, the sequence generated by `elem[n + 1] = elem[n].next()` must contain no
/// repeated values and have `elem[n + 1] > elem[n]` always hold.
///
/// When the generation type is well-behaved, it is guaranteed that [`Id`]s will be unique and dead
/// [`Id`]s won't be able to access new elements at the same index in the stadium.
///
/// All generation types are well-behaved, except for [`NoGen`].
pub trait Gen: Copy + PartialEq + Eq + PartialOrd + Ord + sealed::Sealed {
    const FIRST: Self;

    /// Given the current generation, returns the next generation.
    fn next(self) -> Option<Self>;
    /// Returns whether this generation is a tombstone, i.e. a marker value for generation exhaustion.
    fn is_tombstone(self) -> bool;
}

/// A [`Gen`] type representing the absence of generations.
///
/// Using this type as the generation of a [`Stadium`] means that dead [`Id`]s will still be able
/// to access any subsequent value stored at the same index, causing unpredictable behaviour. You
/// must be careful not to misuse it.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct NoGen;
impl Gen for NoGen {
    const FIRST: Self = NoGen;

    #[inline(always)]
    fn next(self) -> Option<Self> {
        Some(NoGen)
    }

    #[inline(always)]
    fn is_tombstone(self) -> bool {
        false
    }
}

macro_rules! impl_gen {
    ($($ty:ty),*) => {
        $(
            impl Gen for $ty {
                const FIRST: Self = 0;

                #[inline(always)]
                fn next(self) -> Option<Self> {
                    self.checked_add(1)
                }

                #[inline(always)]
                fn is_tombstone(self) -> bool {
                    self == <$ty>::MAX
                }
            }
        )*
    };
}

impl_gen! {
    u8,
    u16,
    u32,
    u64,
    u128
}

/// An identifier for an element in a stadium.
///
/// [`Id`]s are used to access elements in a stadium, and should only be used with the stadium that
/// they originated from. Using an [`Id`] with a stadium that did not create it will not cause
/// undefined behaviour, but it _will_ result in unpredictable behaviour.
///
/// [`Id`]s of elements that have already been removed from the stadium are called _dead_ [`Id`]s.
pub struct Id<T, I, G> {
    pub(crate) index: I,
    pub(crate) gen: G,
    _phantom_data: PhantomData<T>,
}

impl<T, I, G> Id<T, I, G>
where
    G: Gen,
{
    #[inline]
    pub(crate) fn new(index: I, gen: G) -> Self {
        Self {
            index,
            gen,
            _phantom_data: PhantomData,
        }
    }
}

impl<T, I, G> Clone for Id<T, I, G>
where
    I: Index,
    G: Gen,
{
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}

impl<T, I, G> Copy for Id<T, I, G>
where
    I: Index,
    G: Gen,
{
}

impl<T, I, G> PartialEq for Id<T, I, G>
where
    I: Index,
    G: Gen,
{
    fn eq(&self, other: &Self) -> bool {
        self.index == other.index && self.gen == other.gen
    }
}

impl<T, I, G> Eq for Id<T, I, G>
where
    I: Index,
    G: Gen,
{
}

impl<T, I, G> std::fmt::Debug for Id<T, I, G>
where
    I: std::fmt::Debug,
    G: std::fmt::Debug,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}(G{:?})", self.index, self.gen)
    }
}

/// The state of an [`AliveSeat`].
#[derive(Debug, Clone)]
enum SeatState<T, I> {
    /// This seat is empty and might containt a pointer to the next empty seat on the stack.
    Empty(Option<I>),
    /// This seat contains a value.
    Occupied(T),
}

impl<T, I> SeatState<T, I>
where
    I: Index,
{
    #[inline]
    fn as_value(&self) -> Option<&T> {
        if let SeatState::Occupied(value) = self {
            Some(value)
        } else {
            None
        }
    }

    #[inline]
    fn as_value_mut(&mut self) -> Option<&mut T> {
        if let SeatState::Occupied(value) = self {
            Some(value)
        } else {
            None
        }
    }

    #[inline]
    fn into_value(self) -> Option<T> {
        if let SeatState::Occupied(value) = self {
            Some(value)
        } else {
            None
        }
    }

    #[inline]
    fn next_empty(&self) -> Option<I> {
        if let SeatState::Empty(next) = self {
            *next
        } else {
            None
        }
    }
}

#[derive(Debug, Clone)]
struct Seat<T, I, G> {
    gen: G,
    state: SeatState<T, I>,
}

impl<T, I, G> Seat<T, I, G>
where
    G: Gen,
{
    #[inline]
    const fn new() -> Self {
        Self {
            gen: G::FIRST,
            state: SeatState::Empty(None),
        }
    }
}

/// A stadium is a data structure that associates elements with [`Id`]s generated upon insertion.
///
/// # How it Works
/// It does this by storing the elements in a [`Vec`] of 'seats', where each seat can be either
/// occupied or empty and contains a generation that is increased every time an element is removed
/// from it. This way, every element can be uniquely identified by the index of it's seat and it's
/// generation.
///
/// All empty seats contain the index of the next known empty seat, essentially forming a linked
/// list of all empty seats.
///
/// ## Insertion
/// Whenever an element is inserted into a stadium, a seat must be assigned to it. This is done by
/// first checking the list of known empty seats and trying to acquire one if it isn't empty, or by
/// creating a new seat if the list is empty. Then, the [`Id`] of the inserted element will be
/// the index of the seat and it's generation at the moment of insertion.
///
/// ## Removal
/// Whenever an element is removed from a stadium, the seat it's contained in becomes empty and
/// it's generation is increased by one. Then, the seat will point to the current head of the empty
/// seat list and become the new head.
///
/// # Limitations
/// - Stadiums have no way of telling whether an [`Id`] is valid or not, i.e. if it was created by
///   itself. This means that using [`Id`]s created by another stadium _will_ result in unpredictable
///   behaviour (but never _undefined_ behaviour).
#[derive(Debug, Clone)]
pub struct Stadium<T, I, G> {
    /// The seats of this stadium.
    seats: Vec<Seat<T, I, G>>,
    /// How many seats are occupied.
    occupied: I,
    /// The index of the seat at the top of the empty seat stack.
    empty_seats_head: Option<I>,
}

impl<T, I, G> Stadium<T, I, G>
where
    I: Index,
    G: Gen,
{
    /// Creates a new, empty stadium.
    pub fn new() -> Self {
        Self {
            seats: Vec::new(),
            occupied: I::from_usize(0),
            empty_seats_head: None,
        }
    }

    /// Returns the number of elements in this stadium.
    #[inline]
    pub fn len(&self) -> usize {
        self.occupied.to_usize()
    }

    /// Whether this stadium is empty or not.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Gets the seat at the given index.
    #[inline]
    fn get_seat(&self, index: I) -> Option<&Seat<T, I, G>> {
        self.seats.get(index.to_usize())
    }

    /// Gets the seat at the given index.
    #[inline]
    fn get_seat_mut(&mut self, index: I) -> Option<&mut Seat<T, I, G>> {
        self.seats.get_mut(index.to_usize())
    }

    /// Returns a reference to the element with the given [`Id`].
    #[inline]
    pub fn get(&self, id: Id<T, I, G>) -> Option<&T> {
        let seat = self.get_seat(id.index)?;
        if id.gen != seat.gen {
            return None;
        }

        seat.state.as_value()
    }

    /// Returns a mutable reference to the element with the given [`Id`].
    #[inline]
    pub fn get_mut(&mut self, id: Id<T, I, G>) -> Option<&mut T> {
        let seat = self.get_seat_mut(id.index)?;
        if id.gen != seat.gen {
            return None;
        }

        seat.state.as_value_mut()
    }

    /// Acquires a seat from the top of the empty seat list and returns it's index. More
    /// specifically, this will:
    /// - Pop the seat index from the empty seats list
    /// - Update the empty stack to point to the next empty seat
    #[must_use = "the seat will be left unusable if not managed correctly"]
    fn acquire_seat_from_empty_list(&mut self) -> Option<I> {
        let empty_seats_head_index = self.empty_seats_head.take()?;

        // SAFETY: seats in the empty seats list must exist
        let empty_seats_head =
            unsafe { self.get_seat_mut(empty_seats_head_index).unwrap_unchecked() };
        self.empty_seats_head = empty_seats_head.state.next_empty();

        Some(empty_seats_head_index)
    }

    /// Acquires an available seat and returns its index. The seat at the index is guaranteed to be
    /// [`Alive`](Seat::Alive).
    #[inline]
    #[must_use = "the seat will be left unusable if not managed correctly"]
    fn acquire_seat(&mut self) -> I {
        self.acquire_seat_from_empty_list().unwrap_or_else(|| {
            self.seats.push(Seat::new());
            I::from_usize(self.seats.len() - 1)
        })
    }

    /// Inserts a value into this stadium and returns it's [`Id`].
    #[must_use = "the element can only be accessed directly through it's id"]
    pub fn insert(&mut self, value: T) -> Id<T, I, G> {
        self.occupied = self
            .occupied
            .next()
            .unwrap_or_else(|| panic!("exceeded maximum number of elements in the stadium"));
        let index = self.acquire_seat();

        // SAFETY: `acquire_seat` guarantees a seat exists at the given index and that it is alive
        let seat = unsafe { self.get_seat_mut(index).unwrap_unchecked() };
        seat.state = SeatState::Occupied(value);

        Id::new(index, seat.gen)
    }

    /// Removes an value with the given `id` from this stadium and returns it.
    pub fn remove(&mut self, id: Id<T, I, G>) -> Option<T> {
        self.occupied = self.occupied.previous()?;
        let empty_seats_head = std::mem::replace(&mut self.empty_seats_head, Some(id.index));

        let seat = self.get_seat_mut(id.index)?;
        if (id.gen != seat.gen) || seat.state.as_value().is_none() {
            self.occupied = self.occupied.next().unwrap();
            self.empty_seats_head = empty_seats_head;
            return None;
        }

        // ok - seat contains a value
        let new_gen = seat.gen.next().expect("not exhausted");
        let old_state = std::mem::replace(&mut seat.state, SeatState::Empty(empty_seats_head));
        seat.gen = new_gen;

        if new_gen.is_tombstone() {
            self.empty_seats_head = empty_seats_head;
        }

        // SAFETY: the seat was already checked to be non-empty
        unsafe { Some(old_state.into_value().unwrap_unchecked()) }
    }

    /// Clears this stadium. This is equivalent to [removing](Self::remove) every element, one
    /// by one.
    #[inline]
    pub fn clear(&mut self) {
        for index in 0..self.seats.len() {
            let index = I::from_usize(index);
            let seat = self.get_seat(index).expect("in bounds");

            if !seat.gen.is_tombstone() {
                self.remove(Id::new(index, seat.gen));
            }
        }
    }

    /// Returns an iterator of `(Id, &Value)` tuples in this stadium.
    #[inline]
    pub fn iter(&self) -> impl Iterator<Item = (Id<T, I, G>, &T)> {
        self.seats.iter().enumerate().filter_map(|(index, seat)| {
            seat.state
                .as_value()
                .map(|v| (Id::new(I::from_usize(index), seat.gen), v))
        })
    }

    /// Returns an iterator of `(Id, &mut Value)` tuples in this stadium.
    #[inline]
    pub fn iter_mut(&mut self) -> impl Iterator<Item = (Id<T, I, G>, &mut T)> {
        self.seats
            .iter_mut()
            .enumerate()
            .filter_map(|(index, seat)| {
                seat.state
                    .as_value_mut()
                    .map(|v| (Id::new(I::from_usize(index), seat.gen), v))
            })
    }

    /// Returns an iterator over the [`Id`]s of the elements of this stadium.
    #[inline]
    pub fn ids(&self) -> impl Iterator<Item = Id<T, I, G>> + '_ {
        self.seats.iter().enumerate().filter_map(|(index, seat)| {
            seat.state.as_value()?;
            Some(Id::new(I::from_usize(index), seat.gen))
        })
    }

    /// Returns an iterator over references to the elements of this stadium.
    #[inline]
    pub fn values(&self) -> impl Iterator<Item = &T> {
        self.seats.iter().filter_map(|seat| seat.state.as_value())
    }

    /// Returns an iterator over mutable references to the elements of this stadium.
    #[inline]
    pub fn values_mut(&mut self) -> impl Iterator<Item = &mut T> {
        self.seats
            .iter_mut()
            .filter_map(|seat| seat.state.as_value_mut())
    }
}

impl<T, I, G> Default for Stadium<T, I, G>
where
    I: Index,
    G: Gen,
{
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

impl<T, I, G> std::ops::Index<Id<T, I, G>> for Stadium<T, I, G>
where
    I: Index,
    G: Gen,
{
    type Output = T;

    #[inline]
    fn index(&self, id: Id<T, I, G>) -> &Self::Output {
        self.get(id).unwrap()
    }
}

impl<T, I, G> std::ops::IndexMut<Id<T, I, G>> for Stadium<T, I, G>
where
    I: Index,
    G: Gen,
{
    #[inline]
    fn index_mut(&mut self, id: Id<T, I, G>) -> &mut Self::Output {
        self.get_mut(id).unwrap()
    }
}

#[cfg(test)]
mod test {
    use crate::Stadium;
    use std::num::NonZeroU8;

    type TestStadium<T> = Stadium<T, u8, u8>;

    #[test]
    fn test_insert_remove_insert() {
        let mut stadium = TestStadium::new();
        let a = stadium.insert("hi");
        let _ = stadium.insert("hello");

        assert_eq!(stadium.remove(a), Some("hi"));

        let c = stadium.insert("hi again");

        assert_eq!(stadium.remove(a), None);
        assert_eq!(stadium.remove(c), Some("hi again"));
    }

    #[test]
    fn test_tombstone() {
        let mut stadium = TestStadium::new();
        for _ in 0..NonZeroU8::MAX.get() {
            let a = stadium.insert("hi");
            assert_eq!(a.index, 0);
            assert_eq!(stadium.remove(a), Some("hi"));
        }

        let a = stadium.insert("hi");
        assert_eq!(a.index, 1);
        assert_eq!(stadium.remove(a), Some("hi"));
    }

    #[test]
    #[should_panic]
    fn test_max_elements() {
        let mut stadium = TestStadium::new();
        for _ in 0..u32::MAX {
            _ = stadium.insert("hi");
        }

        // one more!
        _ = stadium.insert("hi");
    }

    #[test]
    fn test_get() {
        let mut stadium = TestStadium::new();
        let a = stadium.insert("hi");
        let b = stadium.insert("hello");

        assert_eq!(stadium.get(a), Some(&"hi"));
        assert_eq!(stadium.get(b), Some(&"hello"));

        *stadium.get_mut(a).unwrap() = "hello";
        *stadium.get_mut(b).unwrap() = "world";

        assert_eq!(stadium.get(a), Some(&"hello"));
        assert_eq!(stadium.get(b), Some(&"world"));
    }

    #[test]
    fn test_iter() {
        let mut stadium = TestStadium::new();
        _ = stadium.insert("hi");
        _ = stadium.insert("hello");
        let mut iter = stadium.values();

        assert_eq!(iter.next(), Some(&"hi"));
        assert_eq!(iter.next(), Some(&"hello"));
    }

    #[test]
    fn test_remove_inconsistent() {
        let mut stadium_a = TestStadium::new();
        let mut stadium_b = TestStadium::new();

        let foo = stadium_a.insert("foo");
        let _bar = stadium_a.insert("bar");
        assert_eq!(stadium_a.remove(foo), Some("foo"));

        let baz = stadium_b.insert("baz");
        assert_eq!(stadium_b.remove(baz), Some("baz"));
        let baz = stadium_b.insert("baz");
        assert_eq!(stadium_a.remove(baz), None);
    }
}
